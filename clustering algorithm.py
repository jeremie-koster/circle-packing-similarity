# -*- coding: utf-8 -*-
"""
Created on Wed May  9 10:04:43 2018

@author: Jérémie

Copyright © 2001-2018 Python Software Foundation; All Rights Reserved
"""

# ---------------------------- IMPORTANT ---------------------------------- #
# This code is not fully working. As explained in the MSc Dissertation, 
# it only works if the hierarchical clustering algorithm generates a staircase
# dendrogram. Since the n + n algorithm is not correctly implemented yet
# (the combineTwoPairs function), it is not possible to correctly pack 2 
# clusters of n circles.

# Also, the code doesn't use a fixed dataset, it generates a specific amount of 
# circles with random coordinates and radii. You can change the number of initial
# circles to be generated by changing the parameter when the generate_circles
# function is called. 
# Running several times the code will produce different results as the initial
# circles generated have random coordinates and radii
# ------------------------------------------------------------------------- #


from scipy.cluster.hierarchy import dendrogram, linkage, set_link_color_palette
from scipy.spatial.distance import pdist
import matplotlib.pyplot as plt
from numpy.random import uniform, choice
import numpy as np
from matplotlib.patches import Circle
from math import sqrt,cos,sin,atan2,pi,atan,radians,degrees
import itertools as it
from random import randint

# --------------------------------------------------------------- #
# --------------------- GLOBAL VARIABLES ------------------------ #
# --------------------------------------------------------------- #

width = 1
height = 1

list_of_circles = [] # to compute the linkage table only
list_without_radius = [] # to compute the linkage table only
list_of_clusters = [] # list that stores all LeafCircle and Cluster objects
counter_for_cluster_id = 0 # counter to set id of new cluster objects
number_of_leaves = 0 # only counts the nb of leaves (generated in the beginning)

# ------------------------------------------------------------- #
# ---------------------- CLASSES ------------------------------ #
# ------------------------------------------------------------- #

class LeafCircle:
    def __init__(self,id,x,y,radius):
        self.id = id
        self.x = x
        self.y = y
        self.r = radius
        
    def getCentreCoord(self):
        return np.array([[self.x],[self.y],[1]])
    
    def joinWith (self,circle_to_join): # general function
        if (circle_to_join.id < number_of_leaves): # if joining singleton with singleton
            self.joinToSingleton(circle_to_join)
            print("Join done! 1 + 1 done!")
        elif (circle_to_join.id >= number_of_leaves): # or if joining singleton with cluster
            circle_to_join.addSingleton(self)
            list_of_clusters.remove(self)
            print("Join done! n + 1 done!")
        
    def joinToSingleton (self,circle_to_add): # 1 + 1
        global counter_for_cluster_id
        circle_to_add.x = self.x + self.r + circle_to_add.r # 2nd circle touches 1st on 1 point 
        circle_to_add.y = self.y # 2nd circle on x axis
        list_of_clusters.append(Cluster(counter_for_cluster_id,self,circle_to_add)) # create new cluster
        print("homo coord",circle_to_add.getCentreCoord())
        print("x of circle to add",circle_to_add.x)
        list_of_clusters.remove(self) # and remove both leaf objects from list of clusters
        list_of_clusters.remove(circle_to_add) # same
        counter_for_cluster_id += 1
        print("counter cluster id:",counter_for_cluster_id)
        
# New version         
class Cluster:
    def __init__(self,id,LeafCircle1,LeafCircle2):
        self.id = id
        self.centres = []
        self.radii = []
        self.leaves_id = []
        self.addLeafToCluster(LeafCircle1)
        self.addLeafToCluster(LeafCircle2)
    
    def addLeafToCluster(self,circle_to_add):
        self.centres.append(np.array([[circle_to_add.x],[circle_to_add.y],[1]]))
        self.radii.append(circle_to_add.r)
        self.leaves_id.append(circle_to_add.id)
        
    def addClusterToCluster(self,cluster_to_add):
        for coord in cluster_to_add.centres:
            self.centres.append(np.array([[coord[0][0]],[coord[1][0]],[1]]))
        self.radii.extend(cluster_to_add.radii)
        self.leaves_id.extend(cluster_to_add.leaves_id)
    
    def changeId(self,new_id):
        """ Function to use when 'creating' new cluster after a join of 2 sub-clusters. Instead of deleting old cluster and create a new one after the join, we change the id and increment the counter for later use """
        global counter_for_cluster_id
        self.id = new_id
        counter_for_cluster_id += 1
        print("counter cluster id:",counter_for_cluster_id)
        
    def joinWith(self,circle_to_join):
        if (circle_to_join.id < number_of_leaves): # joining cluster with singleton
            self.addSingleton(circle_to_join)
            print("length of list cluster before removal of singleton ",len(list_of_clusters))
            list_of_clusters.remove(circle_to_join)
            print("length of list cluster after removal of singleton, should be -1 -> ",len(list_of_clusters))
            print("Join done! Singleton added to cluster!")
        elif (circle_to_join.id >= number_of_leaves): # joining cluster with cluster
            print("Two clusters to be joined...")
            self.addCluster(circle_to_join)
            print("n + n join done!")
            list_of_clusters.remove(circle_to_join)

    def addSingleton(self,singleton): # n + 1 function
        """ Function that adds a singleton to a cluster. 
        For each pair of the cluster, if the pair is not too distant, do 1+2 function and store the 2 possibilities. Then, exclude all overlapping elements and choose best possib. Adds the circle object to the list of circles of the cluster, and 'creates' new cluster by changing id   """
        list_of_possib = [] # list of possibilities (should contain LeafCircle objects)
        list_of_checked_elements = [] # list that contains legal elements (no overlapping)
        i = 0
        print("There are {0} circles in the cluster".format(len(self.leaves_id)))
        # we want to select unique pairs of circles 
        for two_ids in it.combinations(self.leaves_id,2):
            index_of_pair1 = self.leaves_id.index(two_ids[0]) # get index of both ids
            index_of_pair2 = self.leaves_id.index(two_ids[1])
            coord_of_pair1 = self.centres[index_of_pair1]
            coord_of_pair2 = self.centres[index_of_pair2]
            pair1_circle = LeafCircle(two_ids[0],coord_of_pair1[0][0],coord_of_pair1[1][0],self.radii[index_of_pair1])
            pair2_circle = LeafCircle(two_ids[1],coord_of_pair2[0][0],coord_of_pair2[1][0],self.radii[index_of_pair2])
            pair = (pair1_circle,pair2_circle) # this is the pair of circles
            if ((pair[1].x - pair[0].x)**2 + (pair[1].y - pair[0].y)**2 <= ((2*singleton.r) + pair[0].r + pair[1].r)**2): # check if the circles of the pair are not too distant from each other
                list_of_possib.extend(twoPlusOne(pair,singleton)) # compute 2 possib of 2 + 1
        print("There are {0} elem in list of possib".format(len(list_of_possib)))
        for element in list_of_possib: # remove overlapping elements
#            print("{0}th element is going to be checked for intersection".format(i))
            i += 1
            if (checkIntersection(self,element) == False):
                list_of_checked_elements.append(element)           
#                print("An element has been added to list of checked elements")
        print("{0} elem have been checked".format(i))
        print("{0} elements in list of possib are going to be compared to take best one".format(len(list_of_checked_elements)))
        self.addLeafToCluster(self.chooseBestPossib(list_of_checked_elements)) # take best possib and add it to the cluster
        self.changeId(counter_for_cluster_id) # pretend to create new cluster. Instead, change cluster id and increment counter
        
    def addCluster(self,cluster2):
        """ Cluster 1 is fixed. Adding cluster 2 agains cluster 1. """
        # TODO: To reduce computational cost, make sure that both pairs are on the outside layer of the cluster
        print("Cluster {0} will be joined with cluster {1}".format(self.id,cluster2.id))
        print("Cluster {0}: {1} circles / Cluster {2}: {3} circles".format(self.id,len(self.leaves_id),cluster2.id,len(cluster2.leaves_id)))

        list = combineTwoPairs(self,cluster2) # contains list of Cluster objects that could fit to cluster2
        
        # TODO: take best possib
        
        # We take the first possibility of the list but this should change. If the code was working, I could develop the 
        # best possib function (with UPGMA)
        newCluster1 = list[0][0]
        newCluster2 = list[0][1]
        inv_matrix = list[0][2]
        newCluster1.addClusterToCluster(newCluster2) # bond both  clusters

        temp_list = []
        for i in inv_matrix@newCluster1.centres:
            temp_list.append(np.array([[i[0][0]],[i[1][0]],[1]]))
        newCluster1.centres = temp_list                            
        
#        newCluster1 = list[randint(0,len(list) - 1)] # in the meantime, just a random possib
        # replace self by cluster1
        self.centres = newCluster1.centres
        self.radii = newCluster1.radii
        self.leaves_id = newCluster1.leaves_id
        
        self.changeId(counter_for_cluster_id)
        print("Cluster {0} has now {1} circles".format(self.id,len(self.leaves_id)))
        
    def chooseBestPossib(self,list):
        """ Function that computes the best possibility to place a new circle in a cluster to have a circle shape. Requires a Cluster object and a list of LeafCircle possibilities """
        longest_distances = [] # list of the biggest distances for each possibility
        
        for possib in list:
            list_of_distances = [] # contains the longest dist for the current possib
            for i in range(len(self.leaves_id)):
                current_x = self.centres[i][0][0]
                current_y = self.centres[i][1][0]
                d = sqrt((possib.y - current_y)**2 + (possib.x - current_x)**2)    
                if (len(list_of_distances) == 0): # for the first iteration
                    list_of_distances.append((d,possib))
                elif (d > list_of_distances[0][0]): # replace element if d is bigger   
                    list_of_distances.pop(0)
                    list_of_distances.append((d,possib))
            longest_distances.append(list_of_distances[0])
        
        while len(longest_distances) > 1: # extract the LeafCircle corresp. to small dist
            if (longest_distances[0][0] >= longest_distances[1][0]):
                del longest_distances[0]
            elif (longest_distances[0][0] < longest_distances[1][0]):
                del longest_distances[1]
        print("length longest distances list",len(longest_distances))
        return longest_distances[0][1] # return LeafCircle object corresponding to smallest dist

# ------------------------------------------------------------------- #     
# ------------------------- FUNCTIONS ------------------------------- #
# ------------------------------------------------------------------- #

def runLinkageTable():
    while len(clean_linkage_matrix) > 0: # as long as LT is not empty... execute the first line
        id_of_first_cluster = clean_linkage_matrix[0][0]
        id_of_second_cluster = clean_linkage_matrix[0][1]
        print("-------I want to join {0} with {1}------".format(id_of_first_cluster,id_of_second_cluster))
        getClusterById(id_of_first_cluster).joinWith(getClusterById(id_of_second_cluster))
        clean_linkage_matrix.pop(0) # deletes current element after use
                    
def transform(translation, angle):
    """ Creates an array to apply translation and rotation to a point. Angle has to be in radians (cos and sin take radians) """
    [tx,ty]=translation
    c = cos(angle)
    s = sin(angle)
    return np.array([[c,-s,tx], [s,c,ty], [0,0,1]]) #standard rotation/tranlation matrix

def checkIntersection(group,circle_to_check):
    """ Checks if a circle is intersecting with any circle of a group of circles. The group can be a cluster object or a pair of circles. Returns True if so, if not, returns False """
    x_to_check = circle_to_check.x
    y_to_check = circle_to_check.y
    r_to_check = circle_to_check.r
    intersec = False
    
    if (type(group) == tuple): # if group is a tuple - in combineTwoPairs function
        for i in range(2):
            current_x = group[i].x
            current_y = group[i].y
            current_r = group[i].r
            if (round(sqrt((x_to_check - current_x)**2 + (y_to_check - current_y)**2),4) < round((r_to_check + current_r),4)): 
                intersec = True
                print("circle is intersecting")
                break
#            print("partie gauche",round((x_to_check - current_x)**2 + (y_to_check - current_y)**2,4))
#            print("partie droite",round(((r_to_check + current_r)**2),4))
    elif (type(group) == Cluster): # if group is a Cluster object
        for i in range(len(group.leaves_id)):
            current_x = group.centres[i][0][0]
            current_y = group.centres[i][1][0]
            current_r = group.radii[i]
            if (round(sqrt((x_to_check - current_x)**2 + (y_to_check - current_y)**2),4) < round((r_to_check + current_r),4)): 
                intersec = True
                print("circle is intersecting")
                break
#            print("partie gauche",round((x_to_check - current_x)**2 + (y_to_check - current_y)**2,4))
#            print("partie droite",round(((r_to_check + current_r)**2),4))
#    print("bool check intersection ->",intersec)
    return intersec

def checkConflicts(cluster,cluster_to_check):
    """ Checks if any circles of 2nd cluster is intersecting with any circle of 1st cluster. Returns True if there is at least 1 intersection. If not, returns False """

    intersec = False
    print("newCluster1 has {0} leaves_id".format(len(cluster.leaves_id)))
    print("Cluster2 has {0} leaves_id".format(len(cluster_to_check.leaves_id)))
    
    for i in range(len(cluster_to_check.leaves_id)): # for each circle in cluster to check
        print("Cluster2 element n°:",i)
        tc_current_x = cluster_to_check.centres[i][0][0]
        tc_current_y = cluster_to_check.centres[i][1][0]
        tc_current_r = cluster_to_check.radii[i]
        for j in range(len(cluster.leaves_id)): # for each circle in fixed cluster
            print("newCluster1 element n°:",j)
            f_current_x = cluster.centres[j][0][0]
            f_current_y = cluster.centres[j][1][0]
            f_current_r = cluster.radii[j]
            if (round(sqrt((tc_current_x - f_current_x)**2 + (tc_current_y - f_current_y)**2),4) < round((tc_current_r + f_current_r),4)): # round seems to be necessary
                intersec = True
                print("circle is intersecting")
                return intersec
    print("Result is:",intersec)
    return intersec

    
def twoPlusOne(cluster,singleton): # 2 + 1 function
    """ Function that computes coordinates (x,y) and (x',y') of 3rd circle C3 that touches the 2 other circles C1 and C2. Takes as parameters tuples of the coordinates and radius of C1 and C2, and the radius of C3 """
    C1 = cluster[0]
    C2 = cluster[1]
    r1,r2,r3 = cluster[0].r, cluster[1].r, singleton.r
    list_to_return = [] # will contain 2 LeafCircle objects of the 2 solutions

    # solving coordinates of C3 given that C1 and C2 centres are on x axis (Pythagorus)
    x = ((r1+r2)**2 + (r1+r3)**2 - (r2+r3)**2)/(2*(r1+r2))
    y = sqrt((r1+r3)**2 - x**2)
    y_symmetric = -y
    C3_before_transformation = np.array([[x],[y],[1]])
    C3_symmetric_before_transformation = np.array([[x],[y_symmetric],[1]])
    
    # rotating and translating (transformation) the result for general case
    alpha = atan2(C2.y - C1.y,C2.x - C1.x)
    matrix = transform([C1.x,C1.y],alpha)
    C3 = matrix@C3_before_transformation
    C3_symmetric = matrix@C3_symmetric_before_transformation
    list_to_return.append(LeafCircle(singleton.id,C3[0][0],C3[1][0],r3))
    list_to_return.append(LeafCircle(singleton.id,C3_symmetric[0][0],C3_symmetric[1][0],r3))
    
    return list_to_return 
       
def combineTwoPairs(cluster1,cluster2):
    list_of_possib = []
    
    for c1_two_ids in it.combinations(cluster1.leaves_id,2):
        c1_index_of_pair1 = cluster1.leaves_id.index(c1_two_ids[0]) # get index of both ids
        c1_index_of_pair2 = cluster1.leaves_id.index(c1_two_ids[1])
        c1_coord_of_pair1 = cluster1.centres[c1_index_of_pair1]
        c1_coord_of_pair2 = cluster1.centres[c1_index_of_pair2]
        c1_pair1_circle = LeafCircle(c1_two_ids[0],c1_coord_of_pair1[0][0],c1_coord_of_pair1[1][0],cluster1.radii[c1_index_of_pair1]) # 1st circle of the pair of cluster1
        c1_pair2_circle = LeafCircle(c1_two_ids[1],c1_coord_of_pair2[0][0],c1_coord_of_pair2[1][0],cluster1.radii[c1_index_of_pair2]) # 2nd circle ofthe pair of cluster2
        # we make sure that the circle with the lowest x is the one that will be on the origin so that the 2nd circle of the pair is on the right side (on the positive side of x axis)
        if (c1_pair1_circle.x < c1_pair2_circle.x):
            c1_pair = (c1_pair1_circle,c1_pair2_circle) # pair of cluster 1
        elif (c1_pair2_circle.x < c1_pair1_circle.x):
            c1_pair = (c1_pair2_circle,c1_pair1_circle)
        if (round((c1_pair2_circle.x - c1_pair1_circle.x)**2 + (c1_pair2_circle.y - c1_pair1_circle.y)**2,4) == round((c1_pair1_circle.r + c1_pair2_circle.r)**2,4)): # check if the 2 circles of the pair are touching themselves
            for c2_two_ids in it.combinations(cluster2.leaves_id,2):
                c2_index_of_pair1 = cluster2.leaves_id.index(c2_two_ids[0]) # get index of both ids
                c2_index_of_pair2 = cluster2.leaves_id.index(c2_two_ids[1])
                c2_coord_of_pair1 = cluster2.centres[c2_index_of_pair1]
                c2_coord_of_pair2 = cluster2.centres[c2_index_of_pair2]
                c2_pair1_circle = LeafCircle(c2_two_ids[0],c2_coord_of_pair1[0][0],c2_coord_of_pair1[1][0],cluster2.radii[c2_index_of_pair1]) # 1st circle of the pair of cluster1
                c2_pair2_circle = LeafCircle(c2_two_ids[1],c2_coord_of_pair2[0][0],c2_coord_of_pair2[1][0],cluster2.radii[c2_index_of_pair2]) # 2nd circle ofthe pair of cluster2
                # the order in the pair is important for the translation & rotation later
                if (computeCoeff(c2_pair1_circle,c2_pair2_circle) < 0):
                    if (c2_pair1_circle.x > c2_pair2_circle.x):
                        c2_pair = (c2_pair1_circle,c2_pair2_circle)
                    elif (c2_pair2_circle.x > c2_pair1_circle.x):
                        c2_pair = (c2_pair2_circle,c2_pair1_circle)
                elif (computeCoeff(c2_pair1_circle,c2_pair2_circle) >= 0):
                    if (c2_pair1_circle.x < c2_pair2_circle.x):
                        c2_pair = (c2_pair1_circle,c2_pair2_circle)
                    elif (c2_pair2_circle.x < c2_pair1_circle.x):
                        c2_pair = (c2_pair2_circle,c2_pair1_circle)
                if (round((c2_pair2_circle.x - c2_pair1_circle.x)**2 + (c2_pair2_circle.y - c2_pair1_circle.y)**2,4) == round((c2_pair1_circle.r + c2_pair2_circle.r)**2,4)): # check if the 2 circles of the pair are touching themselves
                    print("New pair ----------->")
                    # compute transformation matrix for pair 1
                    # Go on new coord system where 1st pair is based on origin
                    # we want to apply rotation first, then translation based on new coord after rotation
                    angle = computeAngleWithAxis(c1_pair)
                    tx = -(cos(angle)*c1_pair[0].x -sin(angle)*c1_pair[0].y)
                    ty = -(sin(angle)*c1_pair[0].x + cos(angle)*c1_pair[0].y)
                    
                    matrix_pair1 = transform([tx,ty],angle)

                    possib_for_this_pair = [] # 8 possibilities of placing 2 circles on 2 circles (missing 4 other possibilities but to simplify the problem, I take only the first 4 ones)
                    list_of_legal_possib = [] # 4 legal possibilities (should be 8, see above)
                    possib_circle_1 = twoPlusOne(c1_pair,c2_pair[0]) # Two possib for 1st circle of 2nd pair
                    # Now, computing 8 (4x2) possibilities for 2nd circle of 2nd pair
                    possib_for_this_pair.extend(twoPlusOne([possib_circle_1[0],c1_pair[0]],c2_pair[1]))
                    possib_for_this_pair.extend(twoPlusOne([possib_circle_1[0],c1_pair[1]],c2_pair[1]))
                    possib_for_this_pair.extend(twoPlusOne([possib_circle_1[1],c1_pair[0]],c2_pair[1]))
                    possib_for_this_pair.extend(twoPlusOne([possib_circle_1[1],c1_pair[1]],c2_pair[1]))
                    print("We have computed the coord of the 4 possibilities")
                    # Remove possibs of 2nd circle of 2nd pair that overlap just with the first pair - the whole cluster needs to be checked for overlappin afterwards. We should have 4 possibs left for 2nd circle of 2nd pair with 2 possib for 1st circle
                    for element in possib_for_this_pair: 
                        if (checkIntersection(c1_pair,element) == False):
                            list_of_legal_possib.append(element)
                    # Put together the 4 new pair possibilities that don't overlap with 1st pair
                    list_of_4_pairs = []
                    list_of_4_pairs.append([possib_circle_1[0],list_of_legal_possib[0]])
                    list_of_4_pairs.append([possib_circle_1[0],list_of_legal_possib[1]])
                    list_of_4_pairs.append([possib_circle_1[1],list_of_legal_possib[2]])
                    list_of_4_pairs.append([possib_circle_1[1],list_of_legal_possib[3]])
                    print("We have removed overlapping elements")                    
                    
                    # Transform cluster 1 into new coord system with matrix_pair1
                    # We have to do like that because we have to keep the centres as a list (not ndarray)
                    cluster1_transformed = cluster1
                    list_transformed_coord = []
                    for elem in matrix_pair1@cluster1_transformed.centres:
                        list_transformed_coord.append(np.array([[elem[0][0]],[elem[1][0]],[1]]))
                    cluster1_transformed.centres = list_transformed_coord

                    k = 0

                    # For each of the 4 new valid pairs, we compute transformation matrix and we transform cluster 2 with it. Then, we check for overlapping (and best possib?)
                    for pair in list_of_4_pairs:
                        print("Trying to compute transform cluster2 for a pair")
                        

                        # Put cluster2 on new coord system - rotation then translation
                        cluster2_transformed = cluster2
                        angle_pair2 = computeAngleTwoLines(c2_pair,pair)
                        rotation_matrix2 = transform([0,0],angle_pair2)
                        coord_c2_transformed = []
                        for i in rotation_matrix2@cluster2.centres:
                            coord_c2_transformed.append(np.array([[i[0][0]],[i[1][0]],[1]]))
                        cluster2_transformed.centres = coord_c2_transformed
                        
                        diff_x = c2_pair[0].x - (cos(angle_pair2)*pair[0].x - sin(angle_pair2)*pair[0].y)
                        diff_y = c2_pair[0].y - (sin(angle_pair2)*pair[0].x + cos(angle_pair2)*pair[0].y)
                        
                        translation_matrix2 = transform([diff_x,diff_y],0)
                        temp_list = []
                        for i in translation_matrix2@cluster2_transformed.centres:
                            temp_list.append(np.array([[i[0][0]],[i[1][0]],[1]]))
                        cluster2_transformed.centres = temp_list

                        # compute inverse transformation matrix for pair 1
                        inv_matrix = np.linalg.inv(matrix_pair1)
                        print("inv matrix:",inv_matrix)
                        
                        cluster1_transformed_back = cluster1_transformed # create a copy
                        
                        # check overlappings between transformed cluster1 and transformed cluster2
                        print("Check conflicts ->")
                        if (checkConflicts(cluster1_transformed_back,cluster2_transformed) == False):
                            
                            list_of_possib.append([cluster1_transformed_back,cluster2_transformed,inv_matrix])
                            k += 1
                    print("For this pair, there are {0} valid possib".format(k))
    
    print("There are {0} possib of placing cluster2 against cluster1".format(len(list_of_possib)))
                    
    return list_of_possib
       
def computeAngleWithAxis(pair1):
    """ Compute angle between line that goes by pair and x axis"""
    
    # compute the coefficient of the line that goes by pair1
    coeff1 = (pair1[1].y - pair1[0].y)/(pair1[1].x - pair1[0].x)
    coeff2 = 0 # because it's x axis
    
    tan_of_alpha = abs((coeff2-coeff1)/(1+(coeff1*coeff2)))
    if (coeff1 >= 0): # if coeff > 0, we have to rotate by -alpha to have both circle horizontally
        alpha = -atan(tan_of_alpha)
    elif (coeff1 < 0):
        alpha = atan(tan_of_alpha)
    print("Angle in degrees with X axis is: ",degrees(alpha))
    return alpha

def computeAngleTwoLines(pair1,pair2):
    """ Compute the angle between the 2 lines that go through each pair """
    
    coeff1 = (pair1[1].y - pair1[0].y)/(pair1[1].x - pair1[0].x)
    coeff2 = (pair2[1].y - pair2[0].y)/(pair2[1].x - pair2[0].x)
    
    tan_of_alpha = abs((coeff2-coeff1)/(1+(coeff1*coeff2)))
    
    alpha = atan(tan_of_alpha)
    print("Angle in degrees between 2 lines is: ",degrees(-alpha))
        
    return -alpha
             
def computeCoeff(circle1,circle2):
    """ Compute the coefficient of the line that goes through both circle"""
    coeff = (circle2.y - circle1.y) / (circle2.x - circle1.x)
    
    return coeff
    
def getClusterById(id):
    """ Method to get a cluster given its id """
    for i in list_of_clusters:
        if (i.id == id):
            return i                            

                            
# ------------------------------------------------------------------ #
# ------------------------- LINKAGE TABLE CREATION ----------------- #
# ------------------------------------------------------------------ #        

def generate_circles(n):
    """ Function that generated a specific amount of circles (n) with random
    coordinates and radii. LeafCircle objects are also created for each 
    circle (only the radius is kept, they are all placed in the origin as their
            position in the final layout will change afterwards) """
    global counter_for_cluster_id
    global number_of_leaves
    while len(list_of_circles) < n: # as long as the list of circles is not full     
        x = uniform(0.05, high = width - 0.05)
        y = uniform(0.05, high = width - 0.05)
        r = uniform(0.02, high = 0.05)
        list_of_clusters.append(LeafCircle(len(list_of_circles),0,0,r)) # add LeafCircle object
        list_of_circles.append([x,y,r])
    counter_for_cluster_id = n
    number_of_leaves = n
        
    
def take_radius_out(list):
    for item in list:
        list_without_radius.append((item[0],item[1]))
    return list_without_radius

generate_circles(8) # Important: nbr of initial circles in parameter
print("\nlist:",list_of_circles)  
print("\nthere are",len(list_of_circles)," elements in the list")   

list_without_radius = take_radius_out(list_of_circles)
print ("\nlist without radius :",list_without_radius)

fig1 = plt.figure(1, figsize =(17,17))
ax1 = fig1.add_subplot(311)
ax1.set_aspect('equal')
ax1.set_xlim((0,1.5))
ax1.set_ylim((0,1.5))

colors = ['blue','c','darkorange','g','magenta','yellow','r','black','maroon','salmon','darkgrey','aqua']
for i in list_of_circles:
    x = i[0]
    y = i[1]
    r = i[2]
    circle = plt.Circle((x,y),r,edgecolor = 'r',fill=False)
    ax1.add_artist(circle)

dist_matrix = pdist(list_without_radius,'euclidean')

linkage_matrix = linkage(dist_matrix, method = 'single')

# keep only the clusters' id from linkage table and convert them into int for following processing
clean_linkage_matrix = []
for i in linkage_matrix:
    cluster_one = int(i[0])
    cluster_two = int(i[1])
    clean_linkage_matrix.append([cluster_one,cluster_two])
print("\nClean linkage table : ",clean_linkage_matrix)

# set up the subplot for the dendrogram tree    
plt.figure(2, figsize=(10,10))
plt.subplot(312)
set_link_color_palette(['m', 'c'])

dendrogram = dendrogram(linkage_matrix)

runLinkageTable()


# set up figure n°2 for the circle packing layout
plt.figure(3, figsize=(17,17))
ax2 = plt.subplot(223)

minx = 1000
maxx = -1000
miny = 1000
maxy = -1000

for circle in list_of_clusters[0].centres:
    if (circle[0][0] < minx):
        minx = circle[0][0]
    if (circle[0][0] > maxx):
        maxx = circle[0][0]
    if (circle[1][0] < miny):
        miny = circle[1][0]
    if (circle[1][0] > maxy):
        maxy = circle[1][0]
    
plt.axis([minx - 0.15,maxx + 0.15,miny - 0.15,maxy + 0.15])
ax2.set_aspect('equal')
ax2.set_yticklabels([])
ax2.set_xticklabels([])

colors = ['blue','c','darkorange','g','magenta','yellow','r','black','maroon','salmon','darkgrey','aqua']

for i in range(len(list_of_clusters[0].leaves_id)):
    print("Plotting circles...")
    current_id = list_of_clusters[0].leaves_id[i]
    current_x = list_of_clusters[0].centres[i][0][0]
    current_y = list_of_clusters[0].centres[i][1][0]
    current_r = list_of_clusters[0].radii[i]
    circle = plt.Circle((current_x,current_y),current_r,edgecolor = colors[current_id],fill=False)
    ax2.add_artist(circle)




# ----- END ------- #